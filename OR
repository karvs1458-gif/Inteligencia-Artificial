import numpy as np
# entradas para la neurna
X = np.array([
    [0,0],
    [0,1],
    [1,0],
    [1,1]
])
#salidas
Y = np.array([0,1,1,1])
#pesos para las entradas
W = [2,5]
#umbral para la funcion de activacion 
umbral = 1

class McCullochPitts:
    def __init__(self, weights, umbral):
        """
        
            Constructor de la neurona MCP.
            Guardar las variables
            weights -> vector de pesos iniciales
            umbral -> umbral para usar en en la funcion de activacion 
        """
        self.weights = weights
        self.umbral = umbral
        
    def predict(self, X):
        """
            Calcula la salida de la neurona para cada fila de entrada X.
        """
        #lista donde se guardan las salidas
        predictions = []
        #recorramos cada fila de entradas
        for i in range(X.shape[0]):
            #calculamos la suma ponderada: w1**1 + w2**2
            weighted_sum = np.dot(self.weights, X[i])
            #mostramos en consola la entrada y la suma ponderada
            print(f"Input: {X[i]}, Weighted Sum: {weighted_sum}")
            #comparacion con el umbral determinar si la neurona se activa o no
            if weighted_sum >= self.umbral:
                predictions.append(1)
            else:
                predictions.append(0)
        return predictions
#instanciamos la clase McCullochPitts
mcp = McCullochPitts(W, umbral)
#calculamos las predicciones
predictions = mcp.predict(X)
#mostramos el resultado final
print("Predictions:",predictions)
